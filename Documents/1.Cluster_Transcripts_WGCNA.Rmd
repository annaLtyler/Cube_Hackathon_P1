---
title: "CAPE in using clustered transcripts in multiple tissues"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

```{r set_type}
#set testing to FALSE to run full gene expression networks and to TRUE
#to run a subset.
#testing = TRUE
testing = FALSE
is.interactive = FALSE
#is.interactive = TRUE
net.type = "signed"
#net.type = "unsigned"

args <- commandArgs(trailingOnly=T)
tissue.type <- args[1]

if(is.na(tissue.type)){
  tissue.type = "Islet"
}
```

The purpose of this workflow is to cluster bulk tissue gene expression 
from the DO mice with WGCNA.

This workflow cluster transcripts separately in the specified tissue,
and runs Islet by default. Other possible tissues are Adipose, Liver,
and SkeletalMuscle.


```{r load_code}
library("here")
all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "gprofiler2", "WGCNA", "qtl2")
load_libraries(all.packages)
```


```{r read_data}



#sink(here("Data", "debugging2.txt"))
#print(tissue.type)
#print(getwd())
#list.files(here("Data"))
#sink()

write.table(here(), here("Data", "test.txt"))

exp.file <- here("Data", "RDS_datasets_tissues", paste0(tissue.type, ".RDS"))
tissue.exp <- readRDS(exp.file)
```

## Filter Expression
Filter the expression matrices to include only genes that have at least
a minimum amount of expression. 

Here we use the raw expression matrix to select transcripts from the rank Z
normalized expression matrix. 

```{r adjust_covar}
min.mean = 10

tissue.trans <- which(colMeans(tissue.exp$data$raw) > min.mean)
tissue.expr <- tissue.exp$data$rz[,tissue.trans]
tissue.covar <- tissue.exp$covar.matrix
adj.expr <- adjust(tissue.expr, tissue.covar)
```


Also collect clinical traits.

```{r pheno}
pheno <- read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE, row.names = 1)
#subset to numeric traits
num.pheno <- apply(pheno[,11:30], 2, as.numeric)
rownames(num.pheno) <- rownames(pheno)
adj.pheno <- adjust(num.pheno, tissue.covar)
gene.table <- tissue.exp$annot.mrna
```


## Cluster gene expression using WGCNA

First cluster gene expression using WGCNA. We will compare these clusters
to those generated by CoExpNets.

```{r wgcna}
wgcna.dir <- here("Results", "WGCNA_Clusters", tissue.type)
if(!file.exists(wgcna.dir)){dir.create(wgcna.dir)}
wgcna.net.file <- file.path(wgcna.dir, paste0("net.RDS"))
if(!file.exists(wgcna.net.file)){
  enableWGCNAThreads()

  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(adj.expr, powerVector = powers, verbose = 5)
  use.power <- sft$powerEstimate
  if(is.na(use.power)){use.power = 6}

  wgcna.net = blockwiseModules(adj.expr, power = use.power, TOMType = net.type, 
  minModuleSize = 10, reassignThreshold = 0, mergeCutHeight = 0.25, 
  numericLabels = TRUE, pamRespectsDendro = FALSE,saveTOMs = FALSE)

  saveRDS(wgcna.net, wgcna.net.file)
}else{
  wgcna.net <- readRDS(wgcna.net.file)
}

mergedColors = labels2colors(wgcna.net$colors)
wgcna.modules <- wgcna.net$colors

pdf(file.path(wgcna.dir, "Modules.pdf"))
for(i in 1:length(wgcna.net$dendrograms)){
	plotDendroAndColors(wgcna.net$dendrograms[[i]], 
  mergedColors[wgcna.net$blockGenes[[i]]], "Module colors", 
  dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
	}
dev.off()

```

## Characterize Modules {.tabset .tabset-fade .tabset-pills}

In each tissue we characterized the modules using gprofiler2. We looked 
for enrichment in all GO domains, as well as KEGG and REACTOME pathways.

The following heatmaps show enriched terms for each set of modules.
Shown are the top 10 most significant terms with fewer than 500 genes.
The islet enrichment plot only shows the top 5 terms per group, since
there are so many modules in this tissue.

```{r get_module_genes}
module_genes <- function(net.obj){
  modules <- gsub("ME", "", colnames(net.obj$MEs))
  moduleV <- net.obj$colors
  module.genes <- lapply(modules, function(x) names(moduleV)[which(moduleV == x)])
  names(module.genes) <- modules
  return(module.genes)
}

characterize_module <- function(enrich.table, n.terms = 10, 
pval_thresh = 0.05, max.term.size = NULL, order.by = "p_value",
decreasing = FALSE){

  low.info.words <- c("to", "of", "the", "process", "or", "by", "in", "and")

  if(length(enrich.table) == 0){return("none")}
  
  if(length(enrich.table) > 1){
    enrichments <- enrich.table[[1]]
    if(length(max.term.size) > 0){
      term.locale <- which(enrichments[,"term_size"] <= max.term.size)
    }else{
      term.locale <- 1:nrow(enrichments)
    }
    if(length(pval_thresh) > 0){
      sig.locale <- which(enrichments[,"p_value"] <= pval_thresh)
    }else{
      sig.locale <- 1:nrow(enrichments)
    }
    take.locale <- intersect(term.locale, sig.locale)
    all.terms <- enrichments[take.locale,"term_name"]
    if(!is.null(order.by)){
      ordered.terms <- enrichments[order(enrichments[,order.by], decreasing = decreasing),]
    }else{
      ordered.terms <- enrichments
    }
    all.terms <- ordered.terms[,"term_name"]
    term.words <- unique(unlist(strsplit(all.terms, " ")))
    pruned.words <- setdiff(term.words, low.info.words)
    top.words <- pruned.words[1:n.terms]
    mod.description <- paste(top.words, collapse = "-")
    return(mod.description)
  }
}
```

### Module Enrichment

```{r enrichment, fig.height = 25, fig.width = 7}
module.genes <- module_genes(wgcna.net)
enrich.file <- file.path(wgcna.dir, "enrich.RDS")
if(!file.exists(enrich.file)){
  enrich <- lapply(module.genes, function(x) gost(x, organism = "mmusculus",
  sources = c("GO", "KEGG", "REACTOME")))
  saveRDS(enrich, enrich.file)
}else{
  enrich <- readRDS(enrich.file)
}
mod.names <- sapply(enrich, 
function(x) characterize_module(x, n.terms = 5, order.by = "p_value", max.term.size = 500))
#pdf("~/Desktop/islet.enrichment.pdf", width = 9, height = 32)
plot.enrichment.group(enrich, max.term.size = 500, plot.label = 
paste(tissue.type, "Modules"), n.terms = 5)
#dev.off()
```

## Trait-Module Correlation {.tabset .tabset-fade .tabset-pills}

We looked at the correlations between each module eigengene and each trait.

```{r mod_eig}
mod.eig <- as.matrix(wgcna.net$MEs)
rownames(mod.eig) <- rownames(adj.expr)

#align the phenotype and eigengene matrices
mod.pheno <- get.xz(mod.eig, adj.pheno)
```

```{r align_mat, width = 12, height = 7}
cor.mat <- matrix(NA, nrow = ncol(mod.pheno$X), ncol = ncol(mod.pheno$Z))
rownames(cor.mat) <- paste0("ME", colnames(mod.pheno$X))
colnames(cor.mat) <- colnames(mod.pheno$Z)

for(i in 1:ncol(mod.pheno$X)){
  for(j in 1:ncol(mod.pheno$Z)){
    #plot.with.model(mod.pheno$X[,i], mod.pheno$Z[,j], report = "cor.test")
    mod.trait.cor <- cor(mod.pheno$X[,i], mod.pheno$Z[,j])
    cor.mat[i,j] <- mod.trait.cor
  }
}
pheatmap(t(cor.mat))
```

## Module mapping  {.tabset .tabset-fade .tabset-pills}

Map each module eigengene. Compare these to the mapping of the WGCNA 
modules in Keller et al. 2018. They are pretty grassy,
except for islet module skyblue3, which has a whopping QTL. I think this 
module is probably the same as Plum1 in Keller 2018.

```{r read_geno_data}
#load genotype data
all.var <- ls()
data.loaded <- as.logical(length(which(all.var == "dataset.DO.Cube.Adipose")))
if(!data.loaded){
  load(here("Data", "dataset.DO.CUBE.multissue.RData"))
}
```

```{r map_islet_modules, fig.width = 12, fig.height = 8}
scan.file <- here("Results", "WGCNA_Clusters", tissue.type, "qtl.scan.RDS")
if(!file.exists(scan.file)){
 scans <- scan1(genoprobs, mod.eig)
 saveRDS(scans, scan.file)
}else{
  scans  <- readRDS(scan.file)
}

mod.dist <- dist(t(scans))
mod.order <- hclust(mod.dist)$order
thresh <- scans[,mod.order]
thresh[which(thresh > 8)] <- 8
par(xpd = TRUE)
multilod.plot(thresh, map = map, lod.thresh = 5, border.lwd = 1, 
row.names = colnames(mod.eig)[mod.order], row.name.shift = -800, 
row.text.cex = 0.7, mar = c(2, 10, 2, 0))
par(xpd = FALSE)

#plot(islet.scans, "MEskyblue3", map = map)
#plot(islet.scans, "MEyellowgreen", map = map)
```