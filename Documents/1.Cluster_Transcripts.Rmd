---
title: "CAPE in using clustered transcripts in multiple tissues"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

```{r set_type}
#set testing to FALSE to run full gene expression networks and to TRUE
#to run a subset.
#testing = TRUE
testing = FALSE
is.interactive = FALSE
#is.interactive = TRUE
net.type = "signed"
#net.type = "unsigned"

tissues = c("Islet", "Liver", "Adipose", "SkeletalMuscle")

args <- commandArgs(trailingOnly=T)
tissue.idx <- as.numeric(args[1])
clust.type <- args[2]

tissue.type <- tissues[tissue.idx]

if(is.na(tissue.type)){
  tissue.type = "Islet"
}

library(here)
clust.dir <- here("Results", paste0(clust.type, "_Clusters"))
if(!file.exists(clust.dir)){dir.create(clust.dir)}
results.dir <- here("Results", paste0(clust.type, "_Clusters"), tissue.type)
if(!file.exists(results.dir)){dir.create(results.dir)}
```

The purpose of this workflow is to cluster bulk tissue gene expression 
from the DO mice with WGCNA and CoExpNets. Downstream analyses will
compare the clustering from these two methods.

This workflow cluster transcripts separately in the specified tissue,
and runs Islet by default. Other possible tissues are Adipose, Liver,
and SkeletalMuscle.


```{r load_code}
all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "gprofiler2", "CoExpNets", "qtl2", "WGCNA")
load_libraries(all.packages)
```


```{r read_data}
exp.file <- here("Data", "RDS_datasets_tissues", paste0(tissue.type, ".RDS"))
tissue.exp <- readRDS(exp.file)
```

## Filter Expression
Filter the expression matrices to include only genes that have at least
a minimum amount of expression. 

Here we use the raw expression matrix to select transcripts from the rank Z
normalized expression matrix. 

```{r adjust_covar}
min.mean = 10

tissue.trans <- which(colMeans(tissue.exp$data$raw) > min.mean)
tissue.expr <- tissue.exp$data$rz[,tissue.trans]
tissue.covar <- tissue.exp$covar.matrix
adj.expr <- adjust(tissue.expr, tissue.covar)
```


Also collect clinical traits.

```{r pheno}
pheno <- read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE, row.names = 1)
#subset to numeric traits
num.pheno <- apply(pheno[,11:30], 2, as.numeric)
rownames(num.pheno) <- rownames(pheno)
adj.pheno <- adjust(num.pheno, tissue.covar)
gene.table <- tissue.exp$annot.mrna
```

## Cluster gene expression using CoExpNets or WGCNA

CoExpNets is WGCNA plus a k-means clustering step that redistributes 
genes across modules. It generally identifies clusters with more even 
size distribution and more specific enrichments than WGCNA.

```{r coExpNets}
if(clust.type == "CoExpNet"){
    #Clustering takes a long time
    #set fullAnnotation to F because function defaults to human.
    #we will do this ourselves by hand.
    net.file <- get.files(results.dir, want = c("net", "rds"), dont.want = "pdf", 
    full.names = TRUE, ignore.case = FALSE)
    if(length(net.file) == 0){
    net.file = CoExpNets::getDownstreamNetwork(tissue=tissue.type,
            net.type = net.type, debug=testing, expr.data = adj.expr,
            job.path= results.dir, save.plots = TRUE, fullAnnotation = F)
    }
    clust.net <- readRDS(net.file)
}
```


```{r wgcna}
if(clust.type == "WGCNA"){
    wgcna.results <- here("Results", "WGCNA_Clusters")
    wgcna.net.file <- file.path(results.dir, paste0("net.RDS"))
    if(!file.exists(wgcna.net.file)){
    enableWGCNAThreads()

    powers = c(c(1:10), seq(from = 12, to=20, by=2))
    sft = pickSoftThreshold(adj.expr, powerVector = powers, verbose = 5)
    use.power <- sft$powerEstimate
    if(is.na(use.power)){use.power = 6}

    clust.net = blockwiseModules(adj.expr, power = use.power, TOMType = net.type, 
    minModuleSize = 10, reassignThreshold = 0, mergeCutHeight = 0.25, 
    numericLabels = TRUE, pamRespectsDendro = FALSE,saveTOMs = FALSE)

    saveRDS(clust.net, wgcna.net.file)
    }else{
    clust.net <- readRDS(wgcna.net.file)
    }

    mergedColors = labels2colors(clust.net$colors)
    wgcna.modules <- clust.net$colors

    pdf(file.path(results.dir, "Modules.pdf"))
    for(i in 1:length(clust.net$dendrograms)){
        plotDendroAndColors(clust.net$dendrograms[[i]], 
    mergedColors[clust.net$blockGenes[[i]]], "Module colors", 
    dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
        }
    dev.off()
}
```

## Characterize Modules {.tabset .tabset-fade .tabset-pills}

In each tissue we characterized the modules using gprofiler2. We looked 
for enrichment in all GO domains, as well as KEGG and REACTOME pathways.

The following heatmaps show enriched terms for each set of modules.
Shown are the top 10 most significant terms with fewer than 500 genes.
The islet enrichment plot only shows the top 5 terms per group, since
there are so many modules in this tissue.

```{r get_module_genes}
module_genes <- function(net.obj){
  modules <- gsub("ME", "", colnames(net.obj$MEs))
  if(clust.type == "CoExpNet"){
    moduleV <- net.obj$moduleColors
  }
  if(clust.type == "WGCNA"){
    moduleV <- net.obj$colors
  }
  module.genes <- lapply(modules, function(x) names(moduleV)[which(moduleV == x)])
  names(module.genes) <- modules
  return(module.genes)
}

characterize_module <- function(enrich.table, n.terms = 10, 
pval_thresh = 0.05, max.term.size = NULL, order.by = "p_value",
decreasing = FALSE){

  low.info.words <- c("to", "of", "the", "process", "or", "by", "in", "and")

  if(length(enrich.table) == 0){return("none")}
  
  if(length(enrich.table) > 1){
    enrichments <- enrich.table[[1]]
    if(length(max.term.size) > 0){
      term.locale <- which(enrichments[,"term_size"] <= max.term.size)
    }else{
      term.locale <- 1:nrow(enrichments)
    }
    if(length(pval_thresh) > 0){
      sig.locale <- which(enrichments[,"p_value"] <= pval_thresh)
    }else{
      sig.locale <- 1:nrow(enrichments)
    }
    take.locale <- intersect(term.locale, sig.locale)
    all.terms <- enrichments[take.locale,"term_name"]
    if(!is.null(order.by)){
      ordered.terms <- enrichments[order(enrichments[,order.by], decreasing = decreasing),]
    }else{
      ordered.terms <- enrichments
    }
    all.terms <- ordered.terms[,"term_name"]
    term.words <- unique(unlist(strsplit(all.terms, " ")))
    pruned.words <- setdiff(term.words, low.info.words)
    top.words <- pruned.words[1:n.terms]
    mod.description <- paste(top.words, collapse = "-")
    return(mod.description)
  }
}
```

### Module Enrichment

```{r enrichment}
module.genes <- module_genes(clust.net)
saveRDS(module.genes, file.path(results.dir, "Module_Membership.RDS"))
enrich.file <- file.path(results.dir, "enrich.RDS")
if(!file.exists(enrich.file)){
  enrich <- lapply(module.genes, function(x) gost(x, organism = "mmusculus",
  sources = c("GO", "KEGG", "REACTOME")))
  saveRDS(enrich, enrich.file)
}else{
  enrich <- readRDS(enrich.file)
}
mod.names <- sapply(enrich, 
function(x) characterize_module(x, n.terms = 5, order.by = "p_value", max.term.size = 500))
```

```{r plot_enrich, fig.width = 9, fig.height = 32}
#enrich_fig <- file.path(results.dir, "Enrichment.jpg")
#jpeg(enrich_fig, width = 9, height = 32, units = "in", res = 300)
plot.enrichment.group(enrich, max.term.size = 500, plot.label = 
paste(tissue.type, "Modules"), n.terms = 5)
#dev.off()

#plot.enrichment.group(enrich, max.term.size = 500, plot.label = 
#paste(tissue.type, "Modules"), n.terms = 5)
```


```{r enrich_plot, results = "asis", echo = FALSE}
#cat(paste0("![](", enrich_fig, "){width=70%}\n"))
```



## Trait-Module Correlation {.tabset .tabset-fade .tabset-pills}

We looked at the correlations between each module eigengene and each trait.

```{r mod_eig}
mod.eig <- as.matrix(clust.net$MEs)
rownames(mod.eig) <- rownames(adj.expr)
write.table(mod.eig, file.path(results.dir, "Module_Eigengenes.RDS"))

#align the phenotype and eigengene matrices
mod.pheno <- get.xz(mod.eig, adj.pheno)
```

```{r align_mat}
cor.mat <- matrix(NA, nrow = ncol(mod.pheno$X), ncol = ncol(mod.pheno$Z))
rownames(cor.mat) <- paste0("ME", colnames(mod.pheno$X))
colnames(cor.mat) <- colnames(mod.pheno$Z)

for(i in 1:ncol(mod.pheno$X)){
  for(j in 1:ncol(mod.pheno$Z)){
    #plot.with.model(mod.pheno$X[,i], mod.pheno$Z[,j], report = "cor.test")
    mod.trait.cor <- cor(mod.pheno$X[,i], mod.pheno$Z[,j])
    cor.mat[i,j] <- mod.trait.cor
  }
}
```

```{r plot_cor, fig.width = 8, fig.height = 8}
#cor_fig <- file.path(results.dir, "Trait_Module_Correlation.Scans.jpg")
#jpeg(cor_fig, width = 8, height = 8, units = "in", res = 300)
pheatmap(t(cor.mat))
#dev.off()

```

```{r cor_plot, results = "asis", echo = FALSE}
#cat(paste0("![](", cor_fig, "){width=100%}\n"))
```


## Module mapping  {.tabset .tabset-fade .tabset-pills}

Map each module eigengene. Compare these to the mapping of the WGCNA 
modules in Keller et al. 2018. They are pretty grassy,
except for islet module skyblue3, which has a whopping QTL. I think this 
module is probably the same as Plum1 in Keller 2018.

```{r read_geno_data}
#load genotype data
all.var <- ls()
data.loaded <- as.logical(length(which(all.var == "dataset.DO.Cube.Adipose")))
if(!data.loaded){
  load(here("Data", "dataset.DO.CUBE.multissue.RData"))
}
```

```{r map_modules, fig.width = 12, fig.height = 8}
scan.file <- file.path(results.dir, "qtl.scan.RDS")
if(!file.exists(scan.file)){
 scans <- scan1(genoprobs, mod.eig, kinship = K)
 saveRDS(scans, scan.file)
}else{
  scans  <- readRDS(scan.file)
}

perm.file <- file.path(results.dir, "qtl.scan.perm.RDS")
if(!file.exists(perm.file)){
 scan.perm <- scan1perm(genoprobs, mod.eig[,1], kinship = K, n_perm = 100)
 saveRDS(scan.perm, perm.file)
}else{
  scan.perm  <- readRDS(perm.file)
}

mod.dist <- dist(t(scans))
mod.order <- hclust(mod.dist)$order
thresh <- scans[,mod.order]
thresh[which(thresh > 8)] <- 8
```

```{r plot_scan, fig.width = 12, fig.height = 6}
#scan_fig <- file.path(results.dir, "Module.Scans.jpg")
#jpeg(scan_fig, width = 12, height = 6, units = "in", res = 300)
par(xpd = TRUE)
multilod.plot(thresh, map = map, lod.thresh = 5, border.lwd = 1, 
row.names = colnames(mod.eig)[mod.order], row.name.shift = -nrow(thresh)*0.011, 
row.text.cex = 0.7, mar = c(2, 10, 2, 0))
par(xpd = FALSE)
#dev.off()
```

```{r scan_plot, results = "asis", echo = FALSE}
#cat(paste0("![](", scan_fig, "){width=70%}\n"))
```
